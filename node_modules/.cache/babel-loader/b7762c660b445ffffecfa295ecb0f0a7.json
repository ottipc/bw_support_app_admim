{"ast":null,"code":"import { fetchUtils } from 'react-admin';\nimport postgrestRestProvider from \"@raphiniert/ra-data-postgrest\";\nimport addUploadFeature from './addUploadFeature';\n\nrequire('dotenv').config();\n\nexport const API_URL = process.env.NODE_ENV === 'production' ? process.env.REACT_APP_PROD_API_URL : process.env.REACT_APP_DEV_API_URL;\n/**\n *\n * dataProvider configurations\n *  Authorization Token for the API\n *\n * @param url\n * @param options\n * @returns {Promise<{status: number; headers: Headers; body: string; json: any}>}\n */\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) {\n    options.headers = new Headers({\n      Accept: 'application/json'\n    });\n  } //options.headers.set('Authorization', process.env.REACT_APP_API_KEY);\n\n\n  return fetchUtils.fetchJson(url, options);\n};\n/**\n * send the Authorization Token in header\n * @type {DataProvider}\n */\n\n\nconsole.log(\"-----------------------\");\nconsole.log(API_URL);\nconsole.log(\"-----------------------\");\nconst dataProvider = postgrestRestProvider(API_URL, httpClient);\n\nfunction buildAndQuery(prop, params) {\n  let querystring = \"\";\n\n  for (prop in params.filter) {\n    console.log(\"PROPERTY : \" + prop);\n    console.log(\"params  \" + params.filter[prop]);\n    querystring = \"&\" + prop + \"=ilike.\" + params.filter[prop] + \"%\";\n\n    if (prop === 'addressid' || 'id_role' || 'id_right' || 'id_user') {\n      querystring = \"&\" + prop + \"=eq.\" + params.filter[prop];\n    }\n  }\n\n  return querystring;\n}\n/**\n *\n * Extending the Dataprovider Functionality to build OR Queries on the Api.\n * The function takes a list of params and their keys to query the specified table with an or.\n *\n * @type {{[p: string]: any, deleteMany: (resource: string, params: DeleteManyParams) => Promise<DeleteManyResult>, updateMany: (resource: string, params: UpdateManyParams) => Promise<UpdateManyResult>, getList: (resource: string, params: GetListParams) => Promise<GetListResult>, getMany: (resource: string, params: GetManyParams) => Promise<GetManyResult>, getManyReference: (resource: string, params: GetManyReferenceParams) => Promise<GetManyReferenceResult>, getOne: (resource: string, params: GetOneParams) => Promise<GetOneResult>, update: (resource: string, params: UpdateParams) => Promise<UpdateResult>, create: (resource: string, params: CreateParams) => Promise<CreateResult>, getManyOr: (function(*, *): Promise<{data: *}>), delete: (resource: string, params: DeleteParams) => Promise<DeleteResult>}}\n */\n\n\nconst myDataProvider = { ...dataProvider\n  /*getList: (resource, params) => {\n      const { page, perPage } = params.pagination;\n      const { field, order } = params.sort;\n      const query = {\n          sort: JSON.stringify([field, order]),\n          range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),\n          filter: JSON.stringify(params.filter),\n      };\n      const url = `${API_URL}/${resource}?${JSON.stringify(query)}`;\n       return httpClient(url).then(({ headers, json }) => ({\n  //            data: json,\n          data: json.map(resource => ({ ...resource, id: resource.addressid }) ),\n          total: parseInt(headers.get('content-range').split('/').pop(), 10),\n      }));\n  },*/\n\n};\n\nconst convertFileToBase64 = file => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n\n  reader.onload = () => resolve(reader.result);\n\n  reader.onerror = reject;\n  reader.readAsDataURL(file.rawFile);\n});\n\nexport default myDataProvider;","map":{"version":3,"sources":["/home/codi/Entwicklung/workspace-webstorm/question_app_admin/src/api/dataProvider.js"],"names":["fetchUtils","postgrestRestProvider","addUploadFeature","require","config","API_URL","process","env","NODE_ENV","REACT_APP_PROD_API_URL","REACT_APP_DEV_API_URL","httpClient","url","options","headers","Headers","Accept","fetchJson","console","log","dataProvider","buildAndQuery","prop","params","querystring","filter","myDataProvider","convertFileToBase64","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL","rawFile"],"mappings":"AAAA,SAAQA,UAAR,QAAyB,aAAzB;AACA,OAAOC,qBAAP,MAAkC,+BAAlC;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;;AACAC,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAAlB;;AAEA,OAAO,MAAMC,OAAO,GAAGC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCF,OAAO,CAACC,GAAR,CAAYE,sBAApD,GAA6EH,OAAO,CAACC,GAAR,CAAYG,qBAAzG;AAGP;;;;;;;;;;AASA,MAAMC,UAAU,GAAG,CAACC,GAAD,EAAMC,OAAO,GAAG,EAAhB,KAAuB;AACtC,MAAI,CAACA,OAAO,CAACC,OAAb,EAAsB;AAClBD,IAAAA,OAAO,CAACC,OAAR,GAAkB,IAAIC,OAAJ,CAAY;AAACC,MAAAA,MAAM,EAAE;AAAT,KAAZ,CAAlB;AACH,GAHqC,CAKtC;;;AACA,SAAOhB,UAAU,CAACiB,SAAX,CAAqBL,GAArB,EAA0BC,OAA1B,CAAP;AAEH,CARD;AAWA;;;;;;AAKAK,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACAD,OAAO,CAACC,GAAR,CAAYd,OAAZ;AACAa,OAAO,CAACC,GAAR,CAAY,yBAAZ;AAEA,MAAMC,YAAY,GAAGnB,qBAAqB,CAACI,OAAD,EAAUM,UAAV,CAA1C;;AAEA,SAASU,aAAT,CAAuBC,IAAvB,EAA6BC,MAA7B,EAAqC;AACjC,MAAIC,WAAW,GAAG,EAAlB;;AACA,OAAKF,IAAL,IAAaC,MAAM,CAACE,MAApB,EAA4B;AACxBP,IAAAA,OAAO,CAACC,GAAR,CAAY,gBAAgBG,IAA5B;AACAJ,IAAAA,OAAO,CAACC,GAAR,CAAa,aAAaI,MAAM,CAACE,MAAP,CAAcH,IAAd,CAA1B;AACAE,IAAAA,WAAW,GAAG,MAAMF,IAAN,GAAa,SAAb,GAAyBC,MAAM,CAACE,MAAP,CAAcH,IAAd,CAAzB,GAA+C,GAA7D;;AACA,QAAIA,IAAI,KAAK,WAAT,IAAwB,SAAxB,IAAqC,UAArC,IAAmD,SAAvD,EAAiE;AAC5DE,MAAAA,WAAW,GAAG,MAAMF,IAAN,GAAa,MAAb,GAAsBC,MAAM,CAACE,MAAP,CAAcH,IAAd,CAApC;AACJ;AACJ;;AACD,SAAOE,WAAP;AACH;AAED;;;;;;;;;AAOA,MAAME,cAAc,GAAG,EACnB,GAAGN;AACH;;;;;;;;;;;;;;;;AAFmB,CAAvB;;AAoBA,MAAMO,mBAAmB,GAAGC,IAAI,IAC5B,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC7B,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AACAD,EAAAA,MAAM,CAACE,MAAP,GAAgB,MAAMJ,OAAO,CAACE,MAAM,CAACG,MAAR,CAA7B;;AACAH,EAAAA,MAAM,CAACI,OAAP,GAAiBL,MAAjB;AAEAC,EAAAA,MAAM,CAACK,aAAP,CAAqBT,IAAI,CAACU,OAA1B;AACH,CAND,CADJ;;AAUA,eAAeZ,cAAf","sourcesContent":["import {fetchUtils} from 'react-admin';\nimport postgrestRestProvider from \"@raphiniert/ra-data-postgrest\";\nimport addUploadFeature from './addUploadFeature';\nrequire('dotenv').config();\n\nexport const API_URL = process.env.NODE_ENV === 'production' ? process.env.REACT_APP_PROD_API_URL : process.env.REACT_APP_DEV_API_URL;\n\n\n/**\n *\n * dataProvider configurations\n *  Authorization Token for the API\n *\n * @param url\n * @param options\n * @returns {Promise<{status: number; headers: Headers; body: string; json: any}>}\n */\nconst httpClient = (url, options = {}) => {\n    if (!options.headers) {\n        options.headers = new Headers({Accept: 'application/json'});\n    }\n\n    //options.headers.set('Authorization', process.env.REACT_APP_API_KEY);\n    return fetchUtils.fetchJson(url, options);\n\n};\n\n\n/**\n * send the Authorization Token in header\n * @type {DataProvider}\n */\n\nconsole.log(\"-----------------------\");\nconsole.log(API_URL);\nconsole.log(\"-----------------------\");\n\nconst dataProvider = postgrestRestProvider(API_URL, httpClient);\n\nfunction buildAndQuery(prop, params) {\n    let querystring = \"\";\n    for (prop in params.filter) {\n        console.log(\"PROPERTY : \" + prop);\n        console.log( \"params  \" + params.filter[prop]);\n        querystring = \"&\" + prop + \"=ilike.\" + params.filter[prop] + \"%\";\n        if (prop === 'addressid' || 'id_role' || 'id_right' || 'id_user'){\n             querystring = \"&\" + prop + \"=eq.\" + params.filter[prop] ;\n        }\n    }\n    return querystring;\n}\n\n/**\n *\n * Extending the Dataprovider Functionality to build OR Queries on the Api.\n * The function takes a list of params and their keys to query the specified table with an or.\n *\n * @type {{[p: string]: any, deleteMany: (resource: string, params: DeleteManyParams) => Promise<DeleteManyResult>, updateMany: (resource: string, params: UpdateManyParams) => Promise<UpdateManyResult>, getList: (resource: string, params: GetListParams) => Promise<GetListResult>, getMany: (resource: string, params: GetManyParams) => Promise<GetManyResult>, getManyReference: (resource: string, params: GetManyReferenceParams) => Promise<GetManyReferenceResult>, getOne: (resource: string, params: GetOneParams) => Promise<GetOneResult>, update: (resource: string, params: UpdateParams) => Promise<UpdateResult>, create: (resource: string, params: CreateParams) => Promise<CreateResult>, getManyOr: (function(*, *): Promise<{data: *}>), delete: (resource: string, params: DeleteParams) => Promise<DeleteResult>}}\n */\nconst myDataProvider = {\n    ...dataProvider,\n    /*getList: (resource, params) => {\n        const { page, perPage } = params.pagination;\n        const { field, order } = params.sort;\n        const query = {\n            sort: JSON.stringify([field, order]),\n            range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),\n            filter: JSON.stringify(params.filter),\n        };\n        const url = `${API_URL}/${resource}?${JSON.stringify(query)}`;\n\n        return httpClient(url).then(({ headers, json }) => ({\n//            data: json,\n            data: json.map(resource => ({ ...resource, id: resource.addressid }) ),\n            total: parseInt(headers.get('content-range').split('/').pop(), 10),\n        }));\n    },*/\n\n};\nconst convertFileToBase64 = file =>\n    new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n\n        reader.readAsDataURL(file.rawFile);\n    });\n\n\nexport default myDataProvider\n"]},"metadata":{},"sourceType":"module"}