{"ast":null,"code":"import { fetchUtils } from 'react-admin';\nimport postgrestRestProvider from \"@raphiniert/ra-data-postgrest\";\n\nrequire('dotenv').config();\n\nexport const API_URL = process.env.NODE_ENV === 'production' ? process.env.REACT_APP_PROD_API_URL : process.env.REACT_APP_DEV_API_URL;\n/**\n *\n * dataProvider configurations\n *  Authorization Token for the API\n *\n * @param url\n * @param options\n * @returns {Promise<{status: number; headers: Headers; body: string; json: any}>}\n */\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) {\n    options.headers = new Headers({\n      Accept: 'application/json'\n    });\n  } //options.headers.set('Authorization', process.env.REACT_APP_API_KEY);\n\n\n  return fetchUtils.fetchJson(url, options);\n};\n/**\n * send the Authorization Token in header\n * @type {DataProvider}\n */\n\n\nconsole.log(\"-----------------------\");\nconsole.log(API_URL);\nconsole.log(\"-----------------------\");\nconst dataProvider = postgrestRestProvider(API_URL, httpClient);\n\nfunction buildAndQuery(prop, params) {\n  let querystring = \"\";\n\n  for (prop in params.filter) {\n    console.log(\"PROPERTY : \" + prop);\n    console.log(\"params  \" + params.filter[prop]);\n    querystring = \"&\" + prop + \"=ilike.\" + params.filter[prop] + \"%\";\n\n    if (prop === 'addressid' || 'id_role' || 'id_right' || 'id_user') {\n      querystring = \"&\" + prop + \"=eq.\" + params.filter[prop];\n    }\n  }\n\n  return querystring;\n}\n/**\n *\n * Extending the Dataprovider Functionality to build OR Queries on the Api.\n * The function takes a list of params and their keys to query the specified table with an or.\n *\n * @type {{[p: string]: any, deleteMany: (resource: string, params: DeleteManyParams) => Promise<DeleteManyResult>, updateMany: (resource: string, params: UpdateManyParams) => Promise<UpdateManyResult>, getList: (resource: string, params: GetListParams) => Promise<GetListResult>, getMany: (resource: string, params: GetManyParams) => Promise<GetManyResult>, getManyReference: (resource: string, params: GetManyReferenceParams) => Promise<GetManyReferenceResult>, getOne: (resource: string, params: GetOneParams) => Promise<GetOneResult>, update: (resource: string, params: UpdateParams) => Promise<UpdateResult>, create: (resource: string, params: CreateParams) => Promise<CreateResult>, getManyOr: (function(*, *): Promise<{data: *}>), delete: (resource: string, params: DeleteParams) => Promise<DeleteResult>}}\n */\n\n\nconst myDataProvider = { ...dataProvider,\n  update: (resource, params) => {\n    console.log(\"Resource : \" + resource);\n\n    if (resource !== 'questions' || !params.data.pictures) {\n      // fallback to the default implementation\n      return dataProvider.update(resource, params);\n    }\n    /**\n     * For posts update only, convert uploaded image in base 64 and attach it to\n     * the `picture` sent property, with `src` and `title` attributes.\n     */\n    // Freshly dropped pictures are File objects and must be converted to base64 strings\n\n\n    const newPictures = params.data.pictures.filter(p => p.rawFile instanceof File);\n    const formerPictures = params.data.pictures.filter(p => !(p.rawFile instanceof File));\n    console.log(\"New pictures : \" + newPictures);\n    console.log(\"New pictures : \" + newPictures);\n    return Promise.all(newPictures.map(convertFileToBase64)).then(base64Pictures => base64Pictures.map(picture64 => ({\n      src: picture64,\n      title: `${params.data.title}`\n    }))).then(transformedNewPictures => dataProvider.update(resource, { ...params,\n      data: { ...params.data,\n        pictures: [...transformedNewPictures, ...formerPictures]\n      }\n    }));\n  }\n  /*getList: (resource, params) => {\n      const { page, perPage } = params.pagination;\n      const { field, order } = params.sort;\n      const query = {\n          sort: JSON.stringify([field, order]),\n          range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),\n          filter: JSON.stringify(params.filter),\n      };\n      const url = `${API_URL}/${resource}?${JSON.stringify(query)}`;\n       return httpClient(url).then(({ headers, json }) => ({\n  //            data: json,\n          data: json.map(resource => ({ ...resource, id: resource.addressid }) ),\n          total: parseInt(headers.get('content-range').split('/').pop(), 10),\n      }));\n  },*/\n\n};\n\nconst convertFileToBase64 = file => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n\n  reader.onload = () => resolve(reader.result);\n\n  reader.onerror = reject;\n  reader.readAsDataURL(file.rawFile);\n});\n\nexport default myDataProvider;","map":{"version":3,"sources":["/home/codi/Entwicklung/workspace-webstorm/question_app_admin/src/api/dataProvider.js"],"names":["fetchUtils","postgrestRestProvider","require","config","API_URL","process","env","NODE_ENV","REACT_APP_PROD_API_URL","REACT_APP_DEV_API_URL","httpClient","url","options","headers","Headers","Accept","fetchJson","console","log","dataProvider","buildAndQuery","prop","params","querystring","filter","myDataProvider","update","resource","data","pictures","newPictures","p","rawFile","File","formerPictures","Promise","all","map","convertFileToBase64","then","base64Pictures","picture64","src","title","transformedNewPictures","file","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL"],"mappings":"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","sourcesContent":["import {fetchUtils} from 'react-admin';\nimport postgrestRestProvider from \"@raphiniert/ra-data-postgrest\";\nrequire('dotenv').config();\n\nexport const API_URL = process.env.NODE_ENV === 'production' ? process.env.REACT_APP_PROD_API_URL : process.env.REACT_APP_DEV_API_URL;\n\n\n/**\n *\n * dataProvider configurations\n *  Authorization Token for the API\n *\n * @param url\n * @param options\n * @returns {Promise<{status: number; headers: Headers; body: string; json: any}>}\n */\nconst httpClient = (url, options = {}) => {\n    if (!options.headers) {\n        options.headers = new Headers({Accept: 'application/json'});\n    }\n\n    //options.headers.set('Authorization', process.env.REACT_APP_API_KEY);\n    return fetchUtils.fetchJson(url, options);\n\n};\n\n\n/**\n * send the Authorization Token in header\n * @type {DataProvider}\n */\n\nconsole.log(\"-----------------------\");\nconsole.log(API_URL);\nconsole.log(\"-----------------------\");\n\nconst dataProvider = postgrestRestProvider(API_URL, httpClient);\n\nfunction buildAndQuery(prop, params) {\n    let querystring = \"\";\n    for (prop in params.filter) {\n        console.log(\"PROPERTY : \" + prop);\n        console.log( \"params  \" + params.filter[prop]);\n        querystring = \"&\" + prop + \"=ilike.\" + params.filter[prop] + \"%\";\n        if (prop === 'addressid' || 'id_role' || 'id_right' || 'id_user'){\n             querystring = \"&\" + prop + \"=eq.\" + params.filter[prop] ;\n        }\n    }\n    return querystring;\n}\n\n/**\n *\n * Extending the Dataprovider Functionality to build OR Queries on the Api.\n * The function takes a list of params and their keys to query the specified table with an or.\n *\n * @type {{[p: string]: any, deleteMany: (resource: string, params: DeleteManyParams) => Promise<DeleteManyResult>, updateMany: (resource: string, params: UpdateManyParams) => Promise<UpdateManyResult>, getList: (resource: string, params: GetListParams) => Promise<GetListResult>, getMany: (resource: string, params: GetManyParams) => Promise<GetManyResult>, getManyReference: (resource: string, params: GetManyReferenceParams) => Promise<GetManyReferenceResult>, getOne: (resource: string, params: GetOneParams) => Promise<GetOneResult>, update: (resource: string, params: UpdateParams) => Promise<UpdateResult>, create: (resource: string, params: CreateParams) => Promise<CreateResult>, getManyOr: (function(*, *): Promise<{data: *}>), delete: (resource: string, params: DeleteParams) => Promise<DeleteResult>}}\n */\nconst myDataProvider = {\n    ...dataProvider,\n    update: (resource, params) => {\n        console.log(\"Resource : \" + resource)\n        if (resource !== 'questions' || !params.data.pictures) {\n            // fallback to the default implementation\n            return dataProvider.update(resource, params);\n        }\n        /**\n         * For posts update only, convert uploaded image in base 64 and attach it to\n         * the `picture` sent property, with `src` and `title` attributes.\n         */\n\n        // Freshly dropped pictures are File objects and must be converted to base64 strings\n        const newPictures = params.data.pictures.filter(\n            p => p.rawFile instanceof File\n            );\n        const formerPictures = params.data.pictures.filter(\n            p => !(p.rawFile instanceof File)\n        );\n        console.log(\"New pictures : \" + newPictures)\n        console.log(\"New pictures : \" + newPictures)\n\n\n\n\n        return Promise.all(newPictures.map(convertFileToBase64))\n            .then(base64Pictures =>\n                base64Pictures.map(picture64 => ({\n                    src: picture64,\n                    title: `${params.data.title}`,\n                }))\n            )\n            .then(transformedNewPictures =>\n                dataProvider.update(resource, {\n                    ...params,\n                    data: {\n                        ...params.data,\n                        pictures: [\n                            ...transformedNewPictures,\n                            ...formerPictures,\n                        ],\n                    },\n                })\n            );\n    },\n\n    /*getList: (resource, params) => {\n        const { page, perPage } = params.pagination;\n        const { field, order } = params.sort;\n        const query = {\n            sort: JSON.stringify([field, order]),\n            range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),\n            filter: JSON.stringify(params.filter),\n        };\n        const url = `${API_URL}/${resource}?${JSON.stringify(query)}`;\n\n        return httpClient(url).then(({ headers, json }) => ({\n//            data: json,\n            data: json.map(resource => ({ ...resource, id: resource.addressid }) ),\n            total: parseInt(headers.get('content-range').split('/').pop(), 10),\n        }));\n    },*/\n\n};\nconst convertFileToBase64 = file =>\n    new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n\n        reader.readAsDataURL(file.rawFile);\n    });\n\n\nexport default myDataProvider\n"]},"metadata":{},"sourceType":"module"}